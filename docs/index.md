
###  ###

## 1.大整数乘法 ##

（算法填空-divideConquer(int X, int Y, int n)）（分治）P122 

![](https://pic.peo.pw/a/2023/02/14/63eb7bc27e47c.png)

结构：

- left(a[], b[], n) - a[]的高位(n/2位)赋值给b[]
- right(a[], b[], n) - a[]的低位(n/2位)赋值给b[]
- Trans2to10(a[]) - 2转10进制
- Trans10to2(a[]) - 10转2进制
- disp(a[]) - 打印整数a[]
- mult(x[], y[], z[], n) - z[] = x[] * y[]，n为x[]和y[]的初始长度（2的次幂）

![](https://pic.peo.pw/a/2023/02/14/63eb7d2ea5857.png)

![](https://pic.peo.pw/a/2023/02/14/63eb7d53195e6.png)


## 2.棋盘覆盖问题 ##

（算法填空-ChessBoard(int tr,int tc,int dr,int dc,int size)）（分治/贪心）P117 

问题：求$2^k\times 2^k$棋盘被L型骨牌"覆盖"(允许留一个空位)的**一个解**

![](https://pic.peo.pw/a/2023/02/14/63eb7f417ba0c.png)

![](https://pic.peo.pw/a/2023/02/14/63eb7fd0b41fa.png)

## 3.循环赛日程表安排问题 ##

（算法填空-Plan(int k)）（分治 - 自底向上）P120 

问题：$n=2^k$个选手仅与其他n-1个选手比赛，设计**一个可行的日程表**

分治：自底向上构建可行解，如：

![](https://pic.peo.pw/a/2023/02/14/63eb809917dbd.png)

![](https://pic.peo.pw/a/2023/02/14/63eb80afe28f3.png)

## 4. 查询第 k 小问题 ##
（算法填空-QuickSelect(int a[ ]，int s，int t，int k)）P109

![](https://pic.peo.pw/a/2023/02/14/63eb80d85ee21.png)

## 5. 求最大和次大元素问题 ##
（算法填空-solve(int a[],int low,int high,int &max1,int &max2)）P105

自顶向下分治：通过左右子区间的最大值和次大值，求出当前区间的最大和次大值

![](https://pic.peo.pw/a/2023/02/14/63eb810b8ddf0.png)


## 6. 动态规划和贪心算法所能求解问题的共同性质 ##
（填空）

最优子结构

## 7. 畜栏问题 ##

（填空-根据问题，能给出每头奶牛的畜栏编号）P262  例7.2

	贪心：按结束时间升序，开始时间升序

## 8. 一般背包问题 ##

（填空-根据问题，能给出最优解和最优解值）P265
	
问题：$$

	贪心：对 value / weight 降序
	
	（本题是“连续”背包，可以用贪心得到最优解）

## 9. 集装箱装载问题 ##

（算法填空-void solve( ) ）p270

	问题：n个集装箱装进轮船；限制：轮船最多承重为W，每个箱子有重量w_i；求最大集装箱数量
	
	贪心：对重量升序排序；取最后一个满足 不大于 W的前缀和

## 10. 多机调度问题 ##

（填空-根据问题，能给出在各台机器上处理作业的总时间）p274

    问题：有n个作业分配给m台机器执行；作业i有处理时间 t_i；最小化总处理时间

    贪心：对处理时间降序排序；开一个优先队列(小根堆)，每次从堆中取最小值x，x累加t_i，x再放回堆中；堆的最大值 = 总处理时间


## 11. 斐波那契数列求解 ##

（算法填空-Fib(int n) ）296

    问题：$f_i = f_{i-1}+f_{i-2}$

    方法：线性推导；递归+记忆化搜索；矩阵快速幂


## 12. **正整数拆分问题** ##
（填空-能够根据算法，将求解过程中得到的值填表） P305

    问题：将正整数n划分为**最多**k个数相加(无序)，求方案数
	
	dp：f(n, k) = 将 n 划分为最多 k 个数相加

	f(n, k) = 
		n < k  ->  f(n, k)
		n == k  ->  f(n, k-1) + f(n, 1)
		n > k  ->  f(n, k-1) + f(n-k, k)
		递归出口：n=1 || k=1 -> 1

## 13. 算法的特征 ##

（选择）

有限性、确定性、可行性、输入性、输出性


## 14. 各个算法所能解决的主要问题 ##

（选择，这个知识点有多道选择题）

常用算法：

- 回溯
	- 采用**深度优先搜索dfs**策略
	- 求解问题的**所有解**或**任一解**
- 分枝限界
	- 采用**广度优先搜索bfs**策略
	- 求解问题的**所有解**或**任一解**
- 贪心
	- 性质：最优子结构（问题的最优解包含其子问题的最优解）
	- 可得到问题的**最优解** 或 某些复杂问题的**近似解**（如NP问题）
	- 通常使用**排序**解决问题
- 分治
	- 步骤：将问题划分为不重不漏的子问题；求解子问题；合并子问题（可省略）
- 动态规划dp
	- 性质：最优子结构，无后效性（当前状态不受后面的状态影响），子问题可重叠（一个子问题可以被多个问题调用）

!!! note
	dp既可以将问题**划分**，也可以进行**覆盖**


（算法思想：穷举/迭代，递归）

## 15. 算法时间复杂度的表示 ##

（判断，这个知识点有多道判断题）

- $\omicron$ - 上界
- $\Omega$ - 下界
- $\Theta$ - 确界


## 16. 芯片测试问题 ##

（判断）

复杂度：$O(n)$

## 17. 二路归并排序问题的时间复杂度 ##

（判断）

$\omicron(n\times \log{n})$

!!! note
	- 归并排序是自底向上的
	- 快速排序是自顶向下的

## 18. 算法设计的目的目标 ##

（选择，通过程序判断违反的目标）

- 正确性：算法能够按照规定的功能和性能正确地执行，这是最基本并且最重要的标准！
- 可使用性：也叫用户友好性，算法能够方便地使用
- 可读性：算法是易于理解的，这要求算法在逻辑上是清晰的、结构化的
- 健壮性：算法具有容错性，即异常处理，能够检测不合理的数据，保证程序不发生异常中断等
- 高效率低存储：效率是指算法的执行时间；存储是指算法执行所用的最大存储空间。算法应该在保证前面的条件下，执行时间尽可能低存储空间尽可能小

## 19. 最大兼容活动集合问题的时间复杂度 ##

（判断）

$\omicron(n\times \log{n})$

## 20. 贪心算法、动态规划算法求解问题的方式 ##

（自底向上还是自顶向下，选择）

- dp - 自底向上 和 自顶向下 均可
- 贪心 - 通常是自顶向下
